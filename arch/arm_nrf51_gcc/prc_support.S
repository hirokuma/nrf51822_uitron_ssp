/*
 *  TOPPERS/SSP Kernel
 *      Smallest Set Profile Kernel
 * 
 *  Copyright (C) 2008 by Embedded and Real-Time Systems Laboratory
 *              Graduate School of Information Science, Nagoya Univ., JAPAN
 *  Copyright (C) 2010 by Meika Sugimoto
 *  Copyright (C) 2013 by Naoki Saito
 *             Nagoya Municipal Industrial Research Institute, JAPAN
 * 
 *  上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
 *  ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 *  変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 *  (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
 *      権表示，この利用条件および下記の無保証規定が，そのままの形でソー
 *      スコード中に含まれていること．
 *  (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
 *      用できる形で再配布する場合には，再配布に伴うドキュメント（利用
 *      者マニュアルなど）に，上記の著作権表示，この利用条件および下記
 *      の無保証規定を掲載すること．
 *  (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
 *      用できない形で再配布する場合には，次のいずれかの条件を満たすこ
 *      と．
 *    (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
 *        作権表示，この利用条件および下記の無保証規定を掲載すること．
 *    (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
 *        報告すること．
 *  (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
 *      害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
 *      また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
 *      由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
 *      免責すること．
 * 
 *  本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 *  よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 *  に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 *  アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 *  の責任を負わない．
 * 
 */

/*
 *  プロセッサ依存モジュール アセンブリ言語部（ARM-M用）
 */

#define TOPPERS_MACRO_ONLY
#define UINT_C(val)		(val)		/* uint_t型の定数を作るマクロ */
#define ULONG_C(val)	(val)		/* ulong_t型の定数を作るマクロ */
#define CAST(type, val)	(val)		/* 型キャストを行うマクロ */

#include "kernel_impl.h"
#include "nordic_nrf51.h"


	.text

/*
 *  外部参照
 */
	.global		intnest

/*
 *  CPU例外エントリ
 *
 *  割込みエントリと処理の内容は同等だが，ログの種類が異なるため，
 *  分けている．
 */
	.align 2
	.syntax unified
	.code 16
	.global exc_entry
	.type exc_entry, function
	/*
	 *  例外/割込みが発生すると，スタック(MSP)にスクラッチレジスタ等が保存される．
	 *  この内容に加えて，CPU例外ハンドラへの情報として，
	 *  EXC_RETURNの情報を保存する．
	 *
	 *   ----------- <----- p_excinf
	 *  | EXC_RETURN|  
	 *   -----------
	 *  |    R0     |  
	 *   -----------
	 *  |    R1     |
	 *   -----------
	 *  |    R2     |
	 *   -----------
	 *  |    R3     |
	 *   -----------
	 *  |    R12    |
	 *   -----------
	 *  |    LR     |
	 *   -----------
	 *  |    PC     |
	 *   -----------
	 *  |   xPSR    |
	 *   -----------
	 *
	 */
exc_entry:
	cpsid i     	/* 外部割込み禁止 */
	push  {lr}  	/* EXC_RETURN を積む			  */
	mov   r0, sp	/* CPU例外ハンドラへの引数となる */
	
	/* 割込みネスト数の加算 */
	ldr r1 , =intnest
	ldr r3 , [r1]
	adds r3 , #1
	str r3 , [r1]

	/*
	 *  共通処理
	 */
exc_entry_2:
	/* ハンドラアドレスを取得 */
	mrs   r2, ipsr   	// r2: 例外番号
	ldr   r1, =_kernel_exc_tbl
	lsls  r3, r2 , #2	// r3 = r2 * 4  (r3:テーブル先頭からのオフセット)
	adds  r3, r3, r1	// r3 = r3 + r1 (r3:要素の格納アドレス)
	ldr   r1, [r3]  	// r1:ハンドラ起動アドレス
	
#ifdef LOG_EXC_ENTER
	push  {r0, r2, r3}
	mov   r0, r2            /* 例外番号をパラメータに  */
	bl    log_exc_enter     /* log_exc_enterを呼び出す */
	pop   {r0, r2, r3}  	// r0:SP, r2:割込み番号
#endif /* LOG_EXC_ENTER */

#ifdef LOG_EXC_LEAVE
	push  { r2 }            /* 例外番号をスタックへ    */
#endif /* LOG_EXC_LEAVE */

	/*
	 *  CPU例外ハンドラの呼び出し
	 */
	cpsie i                 /* ロック解除 */
	blx   r1
	cpsid i                 /* ロック */

#ifdef LOG_EXC_LEAVE
	pop   { r0 }                 /* 例外番号を引数に        */
	bl    log_exc_leave          /* log_exc_leaveを呼び出す */
#endif /* LOG_EXC_LEAVE */
	
	b     ret_exc


/*
 *  割込みエントリ
 */
	.align 2
	.syntax unified
	.code 16
	.global int_entry
	.type int_entry, function
int_entry:
	cpsid i     	/* 外部割込み禁止 */
	push  {lr}  	/* EXC_RETURN を積む */
	mov   r0, sp	/* 未定義の割込みが発生した場合の情報とする */
	
	/*
	 *	共通処理
	 */
int_entry_2:
	/* 割込みネスト数の加算 */
	ldr r1 , =intnest
	ldr r3 , [r1]
	adds r3 , #1
	str r3 , [r1]
	
	/* ハンドラアドレスを取得 */
	mrs   r2, ipsr   	// r2: 割込み番号
	ldr   r1, =_kernel_exc_tbl
	lsls  r3, r2 , #2	// r3 = r2 * 4  (r3:テーブル先頭からのオフセット)
	adds  r3, r3, r1	// r3 = r3 + r1 (r3:要素の格納アドレス)
	ldr   r1, [r3]  	// r1:ハンドラ起動アドレス

#ifdef LOG_INH_ENTER
	push  {r0,r2,r3}
	mov   r0, r2        	/* 割込み番号をパラメータに  */
	bl    log_inh_enter 	/* log_inh_enterを呼び出す */
	pop   { r0,r2,r3 }  	/* r0:SP, r2:割込み番号 */
#endif /* LOG_INH_ENTER */

#ifdef LOG_INH_LEAVE
	push  { r2 }        	/* 割込み番号をスタックへ    */
#endif /* LOG_INH_LEAVE */

	/*
	 *  割込みハンドラの呼び出し
	 */
	cpsie i                 /* ロック解除 */
	blx   r1
	cpsid i                 /* ロック */
	
#ifdef LOG_INH_LEAVE
	pop   { r0 }                   /* 割込み番号を引数に        */
	bl    log_inh_leave          /* log_inh_leaveを呼び出す */
#endif /* LOG_INH_LEAVE */

/*
 *  割込み/例外出口
 *
 *  ret_exc/ret_intは，CPU例外/割込みハンドラから戻った直後に実行する
 *  ルーチンである．
 */
ret_exc:
ret_int:
	/*
	 *  ここで割込みロック状態とするが，すでにPRIMASK.PMをセットしており
	 *  ここで特別に行うことはない
	 */
	/*
	 *  戻り先のコンテキストの判定
	 * 
	 *  intnestが0かどうかで判断する
	 *  
	 */
	/* 割込みネスト数の減算 */
	ldr r1 , =intnest
	ldr r3 , [r1]
	adds r3 , #-1
	str r3 , [r1]
	
	cmp   r3 , #0
	beq   ret_int_2

	/*
	 * 割込み出口(ディスパッチなし)
	 *
	 * 単純に，割込み発生元へ戻る
	 */
ret_int_1:
	/*
	 *  CPUロック状態（PRIMASKがセットされた状態），Handlerモードでくる．
	 *  ThreadモードへのリターンによりPRIMASKの状態が変化しないため
	 *  リターン前に解除する．
	 */ 
	pop		{ r2 }	/* EXC_RETURN --> r2 */
	cpsie	i
	bx	  r2      	/* 割込み(or 例外)発生元リターン */
	
	/*
	 * タスクコンテキストからの割込みの場合
	 */
ret_int_2:
	ldr   r0, =reqflg             /* reqflgがfalseならそのまま戻る */
	ldr   r1, [r0]
	cmp   r1 , #0
	beq    ret_int_1           /* falseならret_int_1へ(そのままリターン) */

	/*
	 * ディスパッチする場合
	 */
ret_int_3:
	movs   r1, #0                   /* reqflgをfalseに */
	str   r1, [r0]
	
	/*
	 *  Threadモードへ移行する．
	 *
	 *  search_schedtsk や run_taskを呼び出す場合は，
	 *  Threadモード，CPUロック状態である必要がある．
	 *  CPUロック状態については既にCPUロックのため，特に行うことはない．
	 *
	 *  Threadモードへの移行には(MSP)スタック上にダミーの例外フレームを置いて，
	 *  擬似的に割込みハンドラからリターンする．
	 */
	pop 	{r2}            	  /* EXC_RETURN --> r2 */
	ldr   r0, =ret_int_4		  /* PC   */
	ldr   r1, =EPSR_T			  /* xPSR(Tビットが'1'である必要がある) */
	stm sp!, {r0-r1}			  /* ダミーフレームをスタック上に積む	*/
	sub   sp, #(EXC_FRAME_SIZE - (4*2)) /* r0-r3,r12,lrの内容は設定する必要がない */
	cpsie	i
	bx	  r2					  /* Threadモードへ移行 */

	/*
	 * ここは Thread モードで動作
	 * 割込み発生時にpushされたレジスタの内容を復帰してリターンする
	 */
ret_int_4:
	bl    search_schedtsk		/* 割込み中で起動されたタスクを実行 */
	bl    run_task
ret_int_r:
	ldr 	r0, [sp, #(EXC_FRAME_SIZE-(4*4))]	// R12
	mov 	r12, r0
	ldr 	r0, [sp, #(EXC_FRAME_SIZE-(4*3))]	// LR
	mov 	lr, r0
	ldr 	r0, [sp, #(EXC_FRAME_SIZE-(4*2))]	// PC
	movs 	r1, #1    	// フラグに影響があるので，xpsrを戻す前に先に処理する
	orrs 	r0, r0, r1	// bit0を1にする(ARMv6-Mは常にThumb実行状態で動作)
	ldr 	r2, [sp, #(EXC_FRAME_SIZE-(4*1))]	// xPSR
	msr 	xpsr_nzcvq, r2
	str 	r0, [sp, #(EXC_FRAME_SIZE-(4*1))]	// 元xPSRの位置にPCの値を置く
	ldmfd 	sp!, {r0-r3}
	add 	sp, sp, #(4*3)  	// sp += (4*3)
	cpsie	i
	pop 	{pc}	// リターン

/*
 *  SVCコールハンドラ(ここは本来不要なので，削除予定)
 */
	.align	2
	.thumb
	.thumb_func
	.globl kernel_svc_handler
	.type kernel_svc_handler, function
kernel_svc_handler:
	cpsie i					/* CPUロック解除状態へ */
	bx		lr				/* リターン	  */

/*
 *  ディスパッチャの動作開始
 */
	.align	2
	.thumb
	.thumb_func
	.globl start_dispatch
	.type start_dispatch, function
start_dispatch:
	/*
	 *  このルーチンは，カーネル起動時に，すべての割込みを禁止した状態
	 * （割込みロック状態と同等）で呼び出される．
	 *  また，Threadモードで呼び出されることを想定している．
	 *
	 *  ここでは，システムの状態をCPUロック状態，割込み優先度マスク全解除状態，
	 *  ディスパッチ許可状態に移行させ，スタックポインタを初期化し，
	 *  dispatcher(task.c) へジャンプする．
	 *
	 *  CPUロック状態と割込みロック状態は共にPRIMASKで制御するよう定義しているため
	 *  すでにシステムはCPUロック状態になっている．
	 *  割込み優先度マスクについては，システム起動時には(プロセッサの)実行優先度が
	 *  最低レベルの優先度であるため，(割込み処理モデルの)割込み優先度マスク全解除状態と
	 *  同等の状態になっている．
	 *  さらに，task_initializeでdisdspをfalseに初期化しているため，
	 *  ディスパッチ許可状態になっている．
	 */
	ldr   r0,=istkpt              /* MSPを初期化   */
	ldr   r1,[r0]                 /* start_dispatch呼び出し時に呼び出し用に */
	msr   msp, r1                 /* 使用しているため初期化する             */
	b	  dispatcher

/*
 *  カーネルの終了処理の呼出し
 *
 *  スタックを初期化
 *  
 */
	.text
	.syntax unified
	.code 16
	.globl call_exit_kernel
	.type call_exit_kernel, function
call_exit_kernel:
	ldr   r0,=istkpt              /* MSPを初期化   */
	ldr   r1,[r0]                 /* start_dispatch呼び出し時に呼び出し用に */
	msr   msp, r1                 /* 使用しているため初期化する             */
	b     exit_kernel       /* カーネルの終了処理を呼ぶ */


/*
 *  微少時間待ち(定数値 SIL_DLY_TIMx については未検証)
 */
	.text
	.syntax unified
	.code 16
	.globl sil_dly_nse
	.type sil_dly_nse, function
sil_dly_nse:
	subs   r0, r0, #SIL_DLY_TIM1
	cmp   r0, #0
	bgt   sil_dly_nse1
	mov   pc, lr
sil_dly_nse1:
	subs   r0, r0, #SIL_DLY_TIM2
	cmp   r0, #0
	bgt   sil_dly_nse1
	mov   pc, lr
